// Code generated by mkserialize.sh; DO NOT EDIT.

package mt

import (
	"bytes"
	"compress/zlib"
	"errors"
	"fmt"
	"image/color"
	"io"
	"math"
	"sort"
	"unicode/utf16"

	"github.com/klauspost/compress/zstd"
)

func write8(w io.Writer, x uint8) {
	_, err := w.Write([]byte{x})
	chk(err)
}
func write16(w io.Writer, x uint16) {
	buf := make([]byte, 2)
	be.PutUint16(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func write32(w io.Writer, x uint32) {
	buf := make([]byte, 4)
	be.PutUint32(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func write64(w io.Writer, x uint64) {
	buf := make([]byte, 8)
	be.PutUint64(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func readBuf(r io.Reader, n int) []byte {
	buf := make([]byte, n)
	_, err := io.ReadFull(r, buf)
	chk(err)
	return buf
}
func read8(r io.Reader) uint8   { return readBuf(r, 1)[0] }
func read16(r io.Reader) uint16 { return be.Uint16(readBuf(r, 2)) }
func read32(r io.Reader) uint32 { return be.Uint32(readBuf(r, 4)) }
func read64(r io.Reader) uint64 { return be.Uint64(readBuf(r, 8)) }

func (obj *ToSrvNil) Serialize(w io.Writer) {
}

func (obj *ToSrvNil) Deserialize(r io.Reader) {
}

func (obj *ToSrvInit) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))[:])
		chk(err)
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		*p = read16(r)
	}
	var local1 []uint8
	var local2 uint16
	{
		p := &local2
		*p = read16(r)
	}
	(local1) = make([]uint8, local2)
	{
		_, err := io.ReadFull(r, (local1)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName) = string(local1)
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit2) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Lang string
	}))(obj)).Lang))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))[:])
		chk(err)
	}
}

func (obj *ToSrvInit2) Deserialize(r io.Reader) {
	var local3 []uint8
	var local4 uint16
	{
		p := &local4
		*p = read16(r)
	}
	(local3) = make([]uint8, local4)
	{
		_, err := io.ReadFull(r, (local3)[:])
		chk(err)
	}
	((*(*(struct {
		Lang string
	}))(obj)).Lang) = string(local3)
}

func (obj *ToSrvJoinModChan) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvJoinModChan) Deserialize(r io.Reader) {
	var local5 []uint8
	var local6 uint16
	{
		p := &local6
		*p = read16(r)
	}
	(local5) = make([]uint8, local6)
	{
		_, err := io.ReadFull(r, (local5)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local5)
}

func (obj *ToSrvLeaveModChan) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvLeaveModChan) Deserialize(r io.Reader) {
	var local7 []uint8
	var local8 uint16
	{
		p := &local8
		*p = read16(r)
	}
	(local7) = make([]uint8, local8)
	{
		_, err := io.ReadFull(r, (local7)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local7)
}

func (obj *ToSrvMsgModChan) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToSrvMsgModChan) Deserialize(r io.Reader) {
	var local9 []uint8
	var local10 uint16
	{
		p := &local10
		*p = read16(r)
	}
	(local9) = make([]uint8, local10)
	{
		_, err := io.ReadFull(r, (local9)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel) = string(local9)
	var local11 []uint8
	var local12 uint16
	{
		p := &local12
		*p = read16(r)
	}
	(local11) = make([]uint8, local12)
	{
		_, err := io.ReadFull(r, (local11)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg) = string(local11)
}

func (obj *ToSrvPlayerPos) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerPos", err))
	}
}

func (obj *ToSrvPlayerPos) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerPos", err))
	}
}

func (obj *ToSrvGotBlks) Serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local13 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local14 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local13] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local13])[local14]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvGotBlks) Deserialize(r io.Reader) {
	var local15 uint8
	{
		p := &local15
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local15)
	for local16 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local17 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local16] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local16])[local17]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) Serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local18 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local19 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local18] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local18])[local19]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) Deserialize(r io.Reader) {
	var local20 uint8
	{
		p := &local20
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local20)
	for local21 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local22 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local21] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local21])[local22]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvInvAction) Serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Action string
		}))(obj)).Action))[:])
		chk(err)
	}
}

func (obj *ToSrvInvAction) Deserialize(r io.Reader) {
	var local23 []uint8
	{
		var err error
		(local23), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Action string
	}))(obj)).Action) = string(local23)
}

func (obj *ToSrvChatMsg) Serialize(w io.Writer) {
	local24 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg))
	if len((local24)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local24)))
		write16(w, uint16(x))
	}
	for local25 := range local24 {
		{
			x := (local24)[local25]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToSrvChatMsg) Deserialize(r io.Reader) {
	var local26 []uint16
	var local27 uint16
	{
		p := &local27
		*p = read16(r)
	}
	(local26) = make([]uint16, local27)
	for local28 := range local26 {
		{
			p := &(local26)[local28]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg = string(utf16.Decode(local26))
}

func (obj *ToSrvFallDmg) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount uint16
		}))(obj)).Amount
		write16(w, uint16(x))
	}
}

func (obj *ToSrvFallDmg) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount uint16
		}))(obj)).Amount
		*p = read16(r)
	}
}

func (obj *ToSrvSelectItem) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Slot uint16
		}))(obj)).Slot
		write16(w, uint16(x))
	}
}

func (obj *ToSrvSelectItem) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Slot uint16
		}))(obj)).Slot
		*p = read16(r)
	}
}

func (obj *ToSrvRespawn) Serialize(w io.Writer) {
}

func (obj *ToSrvRespawn) Deserialize(r io.Reader) {
}

func (obj *ToSrvInteract) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Interaction", err))
	}
	{
		x := (*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		write16(w, uint16(x))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			chk(writePointedThing(w, x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerPos", err))
	}
}

func (obj *ToSrvInteract) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Interaction", err))
	}
	{
		p := &(*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		*p = read16(r)
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			{
				var err error
				*p, err = readPointedThing(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerPos", err))
	}
}

func (obj *ToSrvRemovedSounds) Serialize(w io.Writer) {
	if len(((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			IDs []SoundID
		}))(obj)).IDs)))
		write16(w, uint16(x))
	}
	for local29 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local29]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvRemovedSounds) Deserialize(r io.Reader) {
	var local30 uint16
	{
		p := &local30
		*p = read16(r)
	}
	((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs) = make([]SoundID, local30)
	for local31 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local31]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) Serialize(w io.Writer) {
	for local32 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local32]
			write16(w, uint16(x))
		}
	}
	if len(([]byte((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local33 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local33]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) Deserialize(r io.Reader) {
	for local34 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local34]
			*p = int16(read16(r))
		}
	}
	var local35 []uint8
	var local36 uint16
	{
		p := &local36
		*p = read16(r)
	}
	(local35) = make([]uint8, local36)
	{
		_, err := io.ReadFull(r, (local35)[:])
		chk(err)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local35)
	var local37 uint16
	{
		p := &local37
		*p = read16(r)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local37)
	for local38 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local38]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local39 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local39]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) Deserialize(r io.Reader) {
	var local40 []uint8
	var local41 uint16
	{
		p := &local41
		*p = read16(r)
	}
	(local40) = make([]uint8, local41)
	{
		_, err := io.ReadFull(r, (local40)[:])
		chk(err)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local40)
	var local42 uint16
	{
		p := &local42
		*p = read16(r)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local42)
	for local43 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local43]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
		}
	}
}

func (obj *ToSrvReqMedia) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Filenames []string
	}))(obj)).Filenames)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)))
		write16(w, uint16(x))
	}
	for local44 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		if len(([]byte(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local44]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))[:])
			chk(err)
		}
	}
}

func (obj *ToSrvReqMedia) Deserialize(r io.Reader) {
	var local45 uint16
	{
		p := &local45
		*p = read16(r)
	}
	((*(*(struct {
		Filenames []string
	}))(obj)).Filenames) = make([]string, local45)
	for local46 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		var local47 []uint8
		var local48 uint16
		{
			p := &local48
			*p = read16(r)
		}
		(local47) = make([]uint8, local48)
		{
			_, err := io.ReadFull(r, (local47)[:])
			chk(err)
		}
		(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local46]) = string(local47)
	}
}

func (obj *ToSrvCltReady) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		write8(w, uint8(x))
	}
	if len(([]byte((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		write16(w, uint16(x))
	}
}

func (obj *ToSrvCltReady) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		*p = read8(r)
	}
	var local49 []uint8
	var local50 uint16
	{
		p := &local50
		*p = read16(r)
	}
	(local49) = make([]uint8, local50)
	{
		_, err := io.ReadFull(r, (local49)[:])
		chk(err)
	}
	((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version) = string(local49)
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		*p = read16(r)
	}
}

func (obj *ToSrvFirstSRP) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvFirstSRP) Deserialize(r io.Reader) {
	var local51 uint16
	{
		p := &local51
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt) = make([]byte, local51)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local52 uint16
	{
		p := &local52
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier) = make([]byte, local52)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesA) Serialize(w io.Writer) {
	if len(((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvSRPBytesA) Deserialize(r io.Reader) {
	var local53 uint16
	{
		p := &local53
		*p = read16(r)
	}
	((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A) = make([]byte, local53)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesM) Serialize(w io.Writer) {
	if len(((*(*(struct {
		M []byte
	}))(obj)).M)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			M []byte
		}))(obj)).M)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvSRPBytesM) Deserialize(r io.Reader) {
	var local54 uint16
	{
		p := &local54
		*p = read16(r)
	}
	((*(*(struct {
		M []byte
	}))(obj)).M) = make([]byte, local54)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToCltHello) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
	if len(([]byte((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))[:])
		chk(err)
	}
}

func (obj *ToCltHello) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
	var local55 []uint8
	var local56 uint16
	{
		p := &local56
		*p = read16(r)
	}
	(local55) = make([]uint8, local56)
	{
		_, err := io.ReadFull(r, (local55)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username) = string(local55)
}

func (obj *ToCltAcceptAuth) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		write64(w, uint64(x))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptAuth) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		*p = read64(r)
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptSudoMode) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
	{
		local57 := [15]byte{}
		{
			_, err := w.Write((local57)[:])
			chk(err)
		}
	}
}

func (obj *ToCltAcceptSudoMode) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AuthMethods", err))
	}
	{
		var local58 [15]byte
		local59 := [15]byte{}
		{
			_, err := io.ReadFull(r, (local58)[:])
			chk(err)
		}
		if local58 != local59 {
			chk(fmt.Errorf("const %v: %v", "[15]byte{}", local58))
		}
	}
}

func (obj *ToCltDenySudoMode) Serialize(w io.Writer) {
}

func (obj *ToCltDenySudoMode) Deserialize(r io.Reader) {
}

func (obj *ToCltKick) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		if len(([]byte((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))[:])
			chk(err)
		}
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			x := (*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
}

func (obj *ToCltKick) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		var local60 []uint8
		var local61 uint16
		{
			p := &local61
			*p = read16(r)
		}
		(local60) = make([]uint8, local61)
		{
			_, err := io.ReadFull(r, (local60)[:])
			chk(err)
		}
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom) = string(local60)
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			p := &(*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
}

func (obj *ToCltBlkData) Serialize(w io.Writer) {
	for local62 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			x := ((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local62]
			write16(w, uint16(x))
		}
	}
	{
		w, err := zstd.NewWriter(w)
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MapBlk", err))
		}
		chk(w.Close())
	}
}

func (obj *ToCltBlkData) Deserialize(r io.Reader) {
	for local63 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			p := &((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local63]
			*p = int16(read16(r))
		}
	}
	{
		r, err := zstd.NewReader(byteReader{r})
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MapBlk", err))
		}
		r.Close()
	}
}

func (obj *ToCltAddNode) Serialize(w io.Writer) {
	for local64 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local64]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Node", err))
	}
	{
		x := (*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltAddNode) Deserialize(r io.Reader) {
	for local65 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local65]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Node", err))
	}
	{
		p := &(*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltRemoveNode) Serialize(w io.Writer) {
	for local66 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local66]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltRemoveNode) Deserialize(r io.Reader) {
	for local67 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local67]
			*p = int16(read16(r))
		}
	}
}

func (obj *ToCltInv) Serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltInv) Deserialize(r io.Reader) {
	var local68 []uint8
	{
		var err error
		(local68), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local68)
}

func (obj *ToCltTimeOfDay) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltTimeOfDay) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltCSMRestrictionFlags) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CSMRestrictionFlags", err))
	}
	{
		x := (*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		write32(w, uint32(x))
	}
}

func (obj *ToCltCSMRestrictionFlags) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.CSMRestrictionFlags", err))
	}
	{
		p := &(*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		*p = read32(r)
	}
}

func (obj *ToCltAddPlayerVel) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *ToCltAddPlayerVel) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *ToCltMediaPush) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		RawHash       string
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).RawHash))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).RawHash))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).RawHash))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		RawHash       string
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltMediaPush) Deserialize(r io.Reader) {
	var local69 []uint8
	var local70 uint16
	{
		p := &local70
		*p = read16(r)
	}
	(local69) = make([]uint8, local70)
	{
		_, err := io.ReadFull(r, (local69)[:])
		chk(err)
	}
	((*(*(struct {
		RawHash       string
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).RawHash) = string(local69)
	var local71 []uint8
	var local72 uint16
	{
		p := &local72
		*p = read16(r)
	}
	(local71) = make([]uint8, local72)
	{
		_, err := io.ReadFull(r, (local71)[:])
		chk(err)
	}
	((*(*(struct {
		RawHash       string
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename) = string(local71)
	{
		p := &(*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			RawHash       string
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltChatMsg) Serialize(w io.Writer) {
	{
		local73 := uint8(1)
		{
			x := local73
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ChatMsgType", err))
	}
	local74 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender))
	if len((local74)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local74)))
		write16(w, uint16(x))
	}
	for local75 := range local74 {
		{
			x := (local74)[local75]
			write16(w, uint16(x))
		}
	}
	local76 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text))
	if len((local76)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local76)))
		write16(w, uint16(x))
	}
	for local77 := range local76 {
		{
			x := (local76)[local77]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		write64(w, uint64(x))
	}
}

func (obj *ToCltChatMsg) Deserialize(r io.Reader) {
	{
		var local78 uint8
		local79 := uint8(1)
		{
			p := &local78
			*p = read8(r)
		}
		if local78 != local79 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local78))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ChatMsgType", err))
	}
	var local80 []uint16
	var local81 uint16
	{
		p := &local81
		*p = read16(r)
	}
	(local80) = make([]uint16, local81)
	for local82 := range local80 {
		{
			p := &(local80)[local82]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender = string(utf16.Decode(local80))
	var local83 []uint16
	var local84 uint16
	{
		p := &local84
		*p = read16(r)
	}
	(local83) = make([]uint16, local84)
	for local85 := range local83 {
		{
			p := &(local83)[local85]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text = string(utf16.Decode(local83))
	{
		p := &(*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		*p = int64(read64(r))
	}
}

func (obj *ToCltAORmAdd) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Remove)))
		write16(w, uint16(x))
	}
	for local86 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local86]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
		}
	}
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Add)))
		write16(w, uint16(x))
	}
	for local87 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local87]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAORmAdd) Deserialize(r io.Reader) {
	var local88 uint16
	{
		p := &local88
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove) = make([]AOID, local88)
	for local89 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local89]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
		}
	}
	var local90 uint16
	{
		p := &local90
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add) = make([]AOAdd, local90)
	for local91 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local91]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAOMsgs) Serialize(w io.Writer) {
	for local92 := range (*(*(struct {
		//mt:raw
		Msgs []IDAOMsg
	}))(obj)).Msgs {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:raw
				Msgs []IDAOMsg
			}))(obj)).Msgs)[local92]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.IDAOMsg", err))
		}
	}
}

func (obj *ToCltAOMsgs) Deserialize(r io.Reader) {
	for {
		var local93 IDAOMsg
		err := pcall(func() {
			if err := pcall(func() {
				(local93).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.IDAOMsg", err))
			}
		})
		if err == io.EOF {
			break
		}
		((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs) = append(((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs), local93)
		chk(err)
	}
}

func (obj *ToCltHP) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
			//mt:opt
			DamageEffect bool
		}))(obj)).HP
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				HP uint16
				//mt:opt
				DamageEffect bool
			}))(obj)).DamageEffect
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToCltHP) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
			//mt:opt
			DamageEffect bool
		}))(obj)).HP
		*p = read16(r)
	}
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				HP uint16
				//mt:opt
				DamageEffect bool
			}))(obj)).DamageEffect
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToCltMovePlayer) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovePlayer) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltLegacyKick) Serialize(w io.Writer) {
	local94 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason))
	if len((local94)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local94)))
		write16(w, uint16(x))
	}
	for local95 := range local94 {
		{
			x := (local94)[local95]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltLegacyKick) Deserialize(r io.Reader) {
	var local96 []uint16
	var local97 uint16
	{
		p := &local97
		*p = read16(r)
	}
	(local96) = make([]uint16, local97)
	for local98 := range local96 {
		{
			p := &(local96)[local98]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason = string(utf16.Decode(local96))
}

func (obj *ToCltFOV) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFOV) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDeathScreen) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
}

func (obj *ToCltDeathScreen) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
}

func (obj *ToCltMedia) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)))
		write32(w, uint32(x))
	}
	for local99 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local99]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local99]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local99]).Name))[:])
			chk(err)
		}
		if len(((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local99]).Data)) > math.MaxUint32 {
			chk(ErrTooLong)
		}
		{
			x := uint32(len(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local99]).Data)))
			write32(w, uint32(x))
		}
		{
			_, err := w.Write(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local99]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltMedia) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		*p = read16(r)
	}
	var local100 uint32
	{
		p := &local100
		*p = read32(r)
	}
	((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files) = make([]struct {
		Name string
		Data []byte
	}, local100)
	for local101 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		var local102 []uint8
		var local103 uint16
		{
			p := &local103
			*p = read16(r)
		}
		(local102) = make([]uint8, local103)
		{
			_, err := io.ReadFull(r, (local102)[:])
			chk(err)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local101]).Name) = string(local102)
		var local104 uint32
		{
			p := &local104
			*p = read32(r)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local101]).Data) = make([]byte, local104)
		{
			_, err := io.ReadFull(r, ((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local101]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltNodeDefs) Serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local105 := uint8(1)
				{
					x := local105
					write8(w, uint8(x))
				}
			}
			{
				x := (*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					var b bytes.Buffer
					for i := range x {
						x[i].Serialize(&b)
					}
					if b.Len() > math.MaxUint32 {
						chk(ErrTooLong)
					}
					write32(w, uint32(b.Len()))
					_, err := b.WriteTo(w)
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeDefs) Deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local106 uint8
				local107 := uint8(1)
				{
					p := &local106
					*p = read8(r)
				}
				if local106 != local107 {
					chk(fmt.Errorf("const %v: %v", "uint8(1)", local106))
				}
			}
			{
				p := &(*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					*p = make([]NodeDef, read16(r))
					r := &io.LimitedReader{R: r, N: int64(read32(r))}
					for i := range *p {
						(*p)[i].Deserialize(r)
					}
					if r.N > 0 {
						chk(fmt.Errorf("%d bytes of trailing data", r.N))
					}
				}
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltAnnounceMedia) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)))
		write16(w, uint16(x))
	}
	for local108 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local108]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local108]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local108]).Name))[:])
			chk(err)
		}
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local108]).Base64SHA1))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local108]).Base64SHA1))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local108]).Base64SHA1))[:])
			chk(err)
		}
	}
	if len(([]byte((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))[:])
		chk(err)
	}
}

func (obj *ToCltAnnounceMedia) Deserialize(r io.Reader) {
	var local109 uint16
	{
		p := &local109
		*p = read16(r)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files) = make([]struct {
		Name       string
		Base64SHA1 string
	}, local109)
	for local110 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		var local111 []uint8
		var local112 uint16
		{
			p := &local112
			*p = read16(r)
		}
		(local111) = make([]uint8, local112)
		{
			_, err := io.ReadFull(r, (local111)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local110]).Name) = string(local111)
		var local113 []uint8
		var local114 uint16
		{
			p := &local114
			*p = read16(r)
		}
		(local113) = make([]uint8, local114)
		{
			_, err := io.ReadFull(r, (local113)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local110]).Base64SHA1) = string(local113)
	}
	var local115 []uint8
	var local116 uint16
	{
		p := &local116
		*p = read16(r)
	}
	(local115) = make([]uint8, local116)
	{
		_, err := io.ReadFull(r, (local115)[:])
		chk(err)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL) = string(local115)
}

func (obj *ToCltItemDefs) Serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local117 := uint8(0)
				{
					x := local117
					write8(w, uint8(x))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Defs)))
				write16(w, uint16(x))
			}
			for local118 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local118]).Serialize(w)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ItemDef", err))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)))
				write16(w, uint16(x))
			}
			for local119 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local119]).Alias))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local119]).Alias))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local119]).Alias))[:])
					chk(err)
				}
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local119]).Orig))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local119]).Orig))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local119]).Orig))[:])
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltItemDefs) Deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local120 uint8
				local121 := uint8(0)
				{
					p := &local120
					*p = read8(r)
				}
				if local120 != local121 {
					chk(fmt.Errorf("const %v: %v", "uint8(0)", local120))
				}
			}
			var local122 uint16
			{
				p := &local122
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs) = make([]ItemDef, local122)
			for local123 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local123]).Deserialize(r)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ItemDef", err))
				}
			}
			var local124 uint16
			{
				p := &local124
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases) = make([]struct {
				Alias string
				Orig  string
			}, local124)
			for local125 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				var local126 []uint8
				var local127 uint16
				{
					p := &local127
					*p = read16(r)
				}
				(local126) = make([]uint8, local127)
				{
					_, err := io.ReadFull(r, (local126)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local125]).Alias) = string(local126)
				var local128 []uint8
				var local129 uint16
				{
					p := &local129
					*p = read16(r)
				}
				(local128) = make([]uint8, local129)
				{
					_, err := io.ReadFull(r, (local128)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local125]).Orig) = string(local128)
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltPlaySound) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
	if len(([]byte((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltPlaySound) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
	var local130 []uint8
	var local131 uint16
	{
		p := &local131
		*p = read16(r)
	}
	(local130) = make([]uint8, local131)
	{
		_, err := io.ReadFull(r, (local130)[:])
		chk(err)
	}
	((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name) = string(local130)
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltStopSound) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
}

func (obj *ToCltStopSound) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
}

func (obj *ToCltPrivs) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Privs []string
	}))(obj)).Privs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Privs []string
		}))(obj)).Privs)))
		write16(w, uint16(x))
	}
	for local132 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		if len(([]byte(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local132]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local132]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local132]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltPrivs) Deserialize(r io.Reader) {
	var local133 uint16
	{
		p := &local133
		*p = read16(r)
	}
	((*(*(struct {
		Privs []string
	}))(obj)).Privs) = make([]string, local133)
	for local134 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		var local135 []uint8
		var local136 uint16
		{
			p := &local136
			*p = read16(r)
		}
		(local135) = make([]uint8, local136)
		{
			_, err := io.ReadFull(r, (local135)[:])
			chk(err)
		}
		(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local134]) = string(local135)
	}
}

func (obj *ToCltInvFormspec) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))[:])
		chk(err)
	}
}

func (obj *ToCltInvFormspec) Deserialize(r io.Reader) {
	var local137 []uint8
	var local138 uint32
	{
		p := &local138
		*p = read32(r)
	}
	(local137) = make([]uint8, local138)
	{
		_, err := io.ReadFull(r, (local137)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec) = string(local137)
}

func (obj *ToCltDetachedInv) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltDetachedInv) Deserialize(r io.Reader) {
	var local139 []uint8
	var local140 uint16
	{
		p := &local140
		*p = read16(r)
	}
	(local139) = make([]uint8, local140)
	{
		_, err := io.ReadFull(r, (local139)[:])
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name) = string(local139)
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		*p = read16(r)
	}
	var local141 []uint8
	{
		var err error
		(local141), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local141)
}

func (obj *ToCltShowFormspec) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))[:])
		chk(err)
	}
}

func (obj *ToCltShowFormspec) Deserialize(r io.Reader) {
	var local142 []uint8
	var local143 uint32
	{
		p := &local143
		*p = read32(r)
	}
	(local142) = make([]uint8, local143)
	{
		_, err := io.ReadFull(r, (local142)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec) = string(local142)
	var local144 []uint8
	var local145 uint16
	{
		p := &local145
		*p = read16(r)
	}
	(local144) = make([]uint8, local145)
	{
		_, err := io.ReadFull(r, (local144)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname) = string(local144)
}

func (obj *ToCltMovement) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovement) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSpawnParticle) Serialize(w io.Writer) {
	for local146 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local146]
			write32(w, math.Float32bits(x))
		}
	}
	for local147 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local147]
			write32(w, math.Float32bits(x))
		}
	}
	for local148 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local148]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltSpawnParticle) Deserialize(r io.Reader) {
	for local149 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local149]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local150 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local150]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local151 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local151]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local152 []uint8
	var local153 uint32
	{
		p := &local153
		*p = read32(r)
	}
	(local152) = make([]uint8, local153)
	{
		_, err := io.ReadFull(r, (local152)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))) = string(local152)
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddParticleSpawner) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		write32(w, math.Float32bits(x))
	}
	for local154 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local155 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local154] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local154])[local155]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local156 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local157 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local156] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local156])[local157]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local158 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local159 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local158] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local158])[local159]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local160 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local160]
			write32(w, math.Float32bits(x))
		}
	}
	for local161 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local161]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ParticleSpawnerID", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltAddParticleSpawner) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		*p = math.Float32frombits(read32(r))
	}
	for local162 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local163 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local162] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local162])[local163]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local164 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local165 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local164] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local164])[local165]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local166 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local167 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local166] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local166])[local167]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local168 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local168]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local169 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local169]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local170 []uint8
	var local171 uint32
	{
		p := &local171
		*p = read32(r)
	}
	(local170) = make([]uint8, local171)
	{
		_, err := io.ReadFull(r, (local170)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))) = string(local170)
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ParticleSpawnerID", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddHUD) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUD", err))
	}
}

func (obj *ToCltAddHUD) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUD", err))
	}
}

func (obj *ToCltRmHUD) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
}

func (obj *ToCltRmHUD) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
}

func (obj *ToCltChangeHUD) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local172 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local172]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local173 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local173]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local174 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local174]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local175 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local175]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local176 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local176]
				write32(w, uint32(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltChangeHUD) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local177 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local177]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		var local178 []uint8
		var local179 uint16
		{
			p := &local179
			*p = read16(r)
		}
		(local178) = make([]uint8, local179)
		{
			_, err := io.ReadFull(r, (local178)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name) = string(local178)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local180 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local180]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		var local181 []uint8
		var local182 uint16
		{
			p := &local182
			*p = read16(r)
		}
		(local181) = make([]uint8, local182)
		{
			_, err := io.ReadFull(r, (local181)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text) = string(local181)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local183 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local183]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local184 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local184]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local185 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local185]
				*p = int32(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		var local186 []uint8
		var local187 uint16
		{
			p := &local187
			*p = read16(r)
		}
		(local186) = make([]uint8, local187)
		{
			_, err := io.ReadFull(r, (local186)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2) = string(local186)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltHUDFlags) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDFlags", err))
	}
}

func (obj *ToCltHUDFlags) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDFlags", err))
	}
}

func (obj *ToCltSetHotbarParam) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			local188 := uint16(4) // Size of Size field.
			{
				x := local188
				write16(w, uint16(x))
			}
		}
		{
			x := (*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
	}
}

func (obj *ToCltSetHotbarParam) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			var local189 uint16
			local190 := uint16(4) // Size of Size field.
			{
				p := &local189
				*p = read16(r)
			}
			if local189 != local190 {
				chk(fmt.Errorf("const %v: %v", "uint16(4) // Size of Size field.", local189))
			}
		}
		{
			p := &(*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
	}
}

func (obj *ToCltBreath) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Breath uint16
		}))(obj)).Breath
		write16(w, uint16(x))
	}
}

func (obj *ToCltBreath) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Breath uint16
		}))(obj)).Breath
		*p = read16(r)
	}
}

func (obj *ToCltSkyParams) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))[:])
		chk(err)
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		if len(((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Textures)))
			write16(w, uint16(x))
		}
		for local191 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local191]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
}

func (obj *ToCltSkyParams) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local192 []uint8
	var local193 uint16
	{
		p := &local193
		*p = read16(r)
	}
	(local192) = make([]uint8, local193)
	{
		_, err := io.ReadFull(r, (local192)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type) = string(local192)
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local194 []uint8
	var local195 uint16
	{
		p := &local195
		*p = read16(r)
	}
	(local194) = make([]uint8, local195)
	{
		_, err := io.ReadFull(r, (local194)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType) = string(local194)
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		var local196 uint16
		{
			p := &local196
			*p = read16(r)
		}
		((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures) = make([]Texture, local196)
		for local197 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local197]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
}

func (obj *ToCltOverrideDayNightRatio) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		write16(w, uint16(x))
	}
}

func (obj *ToCltOverrideDayNightRatio) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		*p = read16(r)
	}
}

func (obj *ToCltLocalPlayerAnim) Serialize(w io.Writer) {
	for local198 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local198]
			write32(w, uint32(x))
		}
	}
	for local199 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local199]
			write32(w, uint32(x))
		}
	}
	for local200 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local200]
			write32(w, uint32(x))
		}
	}
	for local201 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local201]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLocalPlayerAnim) Deserialize(r io.Reader) {
	for local202 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local202]
			*p = int32(read32(r))
		}
	}
	for local203 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local203]
			*p = int32(read32(r))
		}
	}
	for local204 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local204]
			*p = int32(read32(r))
		}
	}
	for local205 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local205]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltEyeOffset) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *ToCltEyeOffset) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *ToCltDelParticleSpawner) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltDelParticleSpawner) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltCloudParams) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		write32(w, math.Float32bits(x))
	}
	for local206 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			x := ((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local206]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToCltCloudParams) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		*p = math.Float32frombits(read32(r))
	}
	for local207 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			p := &((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local207]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltFadeSound) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFadeSound) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundID", err))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltUpdatePlayerList) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerListUpdateType", err))
	}
	if len(((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)))
		write16(w, uint16(x))
	}
	for local208 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		if len(([]byte(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local208]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local208]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local208]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltUpdatePlayerList) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.PlayerListUpdateType", err))
	}
	var local209 uint16
	{
		p := &local209
		*p = read16(r)
	}
	((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players) = make([]string, local209)
	for local210 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		var local211 []uint8
		var local212 uint16
		{
			p := &local212
			*p = read16(r)
		}
		(local211) = make([]uint8, local212)
		{
			_, err := io.ReadFull(r, (local211)[:])
			chk(err)
		}
		(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local210]) = string(local211)
	}
}

func (obj *ToCltModChanMsg) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToCltModChanMsg) Deserialize(r io.Reader) {
	var local213 []uint8
	var local214 uint16
	{
		p := &local214
		*p = read16(r)
	}
	(local213) = make([]uint8, local214)
	{
		_, err := io.ReadFull(r, (local213)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel) = string(local213)
	var local215 []uint8
	var local216 uint16
	{
		p := &local216
		*p = read16(r)
	}
	(local215) = make([]uint8, local216)
	{
		_, err := io.ReadFull(r, (local215)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender) = string(local215)
	var local217 []uint8
	var local218 uint16
	{
		p := &local218
		*p = read16(r)
	}
	(local217) = make([]uint8, local218)
	{
		_, err := io.ReadFull(r, (local217)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg) = string(local217)
}

func (obj *ToCltModChanSig) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ModChanSig", err))
	}
	if len(([]byte((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToCltModChanSig) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ModChanSig", err))
	}
	var local219 []uint8
	var local220 uint16
	{
		p := &local220
		*p = read16(r)
	}
	(local219) = make([]uint8, local220)
	{
		_, err := io.ReadFull(r, (local219)[:])
		chk(err)
	}
	((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel) = string(local219)
}

func (obj *ToCltNodeMetasChanged) Serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				w := zlib.NewWriter(w)
				if x == nil {
					write8(w, 0)
				} else {
					write8(w, 2)
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					keys := make([][3]int16, 0, len(x))
					for key := range x {
						keys = append(keys, key)
					}
					sort.Slice(keys, func(i, j int) bool {
						p, q := keys[i], keys[j]
						for i := range p {
							switch {
							case p[i] < q[i]:
								return true
							case p[i] > q[i]:
								return false
							}
						}
						return false
					})
					for _, key := range keys {
						for _, n := range key {
							write16(w, uint16(n))
						}
						chk(serialize(w, x[key]))
					}
				}
				chk(w.Close())
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeMetasChanged) Deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				switch ver := read8(r); ver {
				case 0:
					*p = nil
				case 2:
					n := read16(r)
					*p = make(map[[3]int16]*NodeMeta, n)
					for ; n > 0; n-- {
						var pos [3]int16
						for i := range pos {
							pos[i] = int16(read16(r))
						}
						nm := new(NodeMeta)
						chk(deserialize(r, nm))
						(*p)[pos] = nm
					}
				default:
					chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
				}
				chk(r.Close())
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltSunParams) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSunParams) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMoonParams) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMoonParams) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStarParams) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltStarParams) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSRPBytesSaltB) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).B)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltSRPBytesSaltB) Deserialize(r io.Reader) {
	var local221 uint16
	{
		p := &local221
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt) = make([]byte, local221)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local222 uint16
	{
		p := &local222
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).B) = make([]byte, local222)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Prepend string
	}))(obj)).Prepend))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) Deserialize(r io.Reader) {
	var local223 []uint8
	var local224 uint16
	{
		p := &local224
		*p = read16(r)
	}
	(local223) = make([]uint8, local224)
	{
		_, err := io.ReadFull(r, (local223)[:])
		chk(err)
	}
	((*(*(struct {
		Prepend string
	}))(obj)).Prepend) = string(local223)
}

func (obj *AOCmdProps) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOProps", err))
	}
}

func (obj *AOCmdProps) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOProps", err))
	}
}

func (obj *AOCmdPos) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOPos", err))
	}
}

func (obj *AOCmdPos) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOPos", err))
	}
}

func (obj *AOCmdTextureMod) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
}

func (obj *AOCmdTextureMod) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
}

func (obj *AOCmdSprite) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOSprite", err))
	}
}

func (obj *AOCmdSprite) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOSprite", err))
	}
}

func (obj *AOCmdHP) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *AOCmdHP) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *AOCmdArmorGroups) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Armor []Group
	}))(obj)).Armor)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Armor []Group
		}))(obj)).Armor)))
		write16(w, uint16(x))
	}
	for local225 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local225]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
		}
	}
}

func (obj *AOCmdArmorGroups) Deserialize(r io.Reader) {
	var local226 uint16
	{
		p := &local226
		*p = read16(r)
	}
	((*(*(struct {
		Armor []Group
	}))(obj)).Armor) = make([]Group, local226)
	for local227 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local227]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
		}
	}
}

func (obj *AOCmdAnim) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAnim", err))
	}
}

func (obj *AOCmdAnim) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAnim", err))
	}
}

func (obj *AOCmdBonePos) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOBonePos", err))
	}
}

func (obj *AOCmdBonePos) Deserialize(r io.Reader) {
	var local228 []uint8
	var local229 uint16
	{
		p := &local229
		*p = read16(r)
	}
	(local228) = make([]uint8, local229)
	{
		_, err := io.ReadFull(r, (local228)[:])
		chk(err)
	}
	((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone) = string(local228)
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOBonePos", err))
	}
}

func (obj *AOCmdAttach) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAttach", err))
	}
}

func (obj *AOCmdAttach) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOAttach", err))
	}
}

func (obj *AOCmdPhysOverride) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdPhysOverride) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdSpawnInfant) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		local230 := genericCAO
		if err := pcall(func() {
			(local230).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.aoType", err))
		}
	}
}

func (obj *AOCmdSpawnInfant) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		var local231 aoType
		local232 := genericCAO
		if err := pcall(func() {
			(local231).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.aoType", err))
		}
		if local231 != local232 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local231))
		}
	}
}

func (obj *AOCmdAnimSpeed) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOCmdAnimSpeed) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *NodeMeta) Serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:len32
			Fields []NodeMetaField

			Inv Inv
		}))(obj)).Fields)))
		write32(w, uint32(x))
	}
	for local233 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local233]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Serialize(w))
}

func (obj *NodeMeta) Deserialize(r io.Reader) {
	var local234 uint32
	{
		p := &local234
		*p = read32(r)
	}
	((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields) = make([]NodeMetaField, local234)
	for local235 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local235]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Deserialize(r))
}

func (obj *MinimapMode) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MinimapType", err))
	}
	if len(([]byte((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		write16(w, uint16(x))
	}
}

func (obj *MinimapMode) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MinimapType", err))
	}
	var local236 []uint8
	var local237 uint16
	{
		p := &local237
		*p = read16(r)
	}
	(local236) = make([]uint8, local237)
	{
		_, err := io.ReadFull(r, (local236)[:])
		chk(err)
	}
	((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label) = string(local236)
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		*p = read16(r)
	}
}

func (obj *NodeDef) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Param0).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local238 := uint8(13)
			{
				x := local238
				write8(w, uint8(x))
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local239 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).Groups)[local239]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).P1Type).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).P2Type).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrawType).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DrawType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Mesh))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Mesh))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Mesh))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Scale
			write32(w, math.Float32bits(x))
		}
		{
			local240 := uint8(6)
			{
				x := local240
				write8(w, uint8(x))
			}
		}
		for local241 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).Tiles)[local241]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		for local242 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local242]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		{
			local243 := uint8(6)
			{
				x := local243
				write8(w, uint8(x))
			}
		}
		for local244 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local244]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Palette).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Waving).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.WaveType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			write8(w, uint8(x))
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).ConnectTo)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).ConnectTo)))
			write16(w, uint16(x))
		}
		for local245 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local245]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).InsideTint
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Level
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Translucent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Transparent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LightSrc
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).GndContent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Collides
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Pointable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Diggable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Climbable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Replaceable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			write32(w, uint32(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiquidType).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.LiquidType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).FlowingAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).SrcAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).SrcAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).SrcAlt))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Viscosity
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FlowRange
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Floodable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrawBox).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).ColBox).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).SelBox).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DugSnd).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).DigPredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DigPredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DigPredict))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).AlphaUse).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AlphaUse", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *NodeDef) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Param0).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local246 uint8
			local247 := uint8(13)
			{
				p := &local246
				*p = read8(r)
			}
			if local246 != local247 {
				chk(fmt.Errorf("const %v: %v", "uint8(13)", local246))
			}
		}
		var local248 []uint8
		var local249 uint16
		{
			p := &local249
			*p = read16(r)
		}
		(local248) = make([]uint8, local249)
		{
			_, err := io.ReadFull(r, (local248)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Name) = string(local248)
		var local250 uint16
		{
			p := &local250
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Groups) = make([]Group, local250)
		for local251 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).Groups)[local251]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).P1Type).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).P2Type).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrawType).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DrawType", err))
		}
		var local252 []uint8
		var local253 uint16
		{
			p := &local253
			*p = read16(r)
		}
		(local252) = make([]uint8, local253)
		{
			_, err := io.ReadFull(r, (local252)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Mesh) = string(local252)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Scale
			*p = math.Float32frombits(read32(r))
		}
		{
			var local254 uint8
			local255 := uint8(6)
			{
				p := &local254
				*p = read8(r)
			}
			if local254 != local255 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local254))
			}
		}
		for local256 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).Tiles)[local256]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		for local257 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local257]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		{
			var local258 uint8
			local259 := uint8(6)
			{
				p := &local258
				*p = read8(r)
			}
			if local258 != local259 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local258))
			}
		}
		for local260 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local260]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileDef", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Palette).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Waving).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.WaveType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			*p = read8(r)
		}
		var local261 uint16
		{
			p := &local261
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).ConnectTo) = make([]Content, local261)
		for local262 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance uint8

					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local262]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).InsideTint
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Level
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Translucent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Transparent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LightSrc
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).GndContent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Collides
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Pointable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Diggable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Climbable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Replaceable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			*p = int32(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiquidType).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.LiquidType", err))
		}
		var local263 []uint8
		var local264 uint16
		{
			p := &local264
			*p = read16(r)
		}
		(local263) = make([]uint8, local264)
		{
			_, err := io.ReadFull(r, (local263)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).FlowingAlt) = string(local263)
		var local265 []uint8
		var local266 uint16
		{
			p := &local266
			*p = read16(r)
		}
		(local265) = make([]uint8, local266)
		{
			_, err := io.ReadFull(r, (local265)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).SrcAlt) = string(local265)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Viscosity
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FlowRange
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).Floodable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DrawBox).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).ColBox).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).SelBox).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).DugSnd).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		var local267 []uint8
		var local268 uint16
		{
			p := &local268
			*p = read16(r)
		}
		(local267) = make([]uint8, local268)
		{
			_, err := io.ReadFull(r, (local267)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance uint8

			LiquidMovePhysics bool
		}))(obj)).DigPredict) = string(local267)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).AlphaUse).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AlphaUse", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance uint8

				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *PointedNode) Serialize(w io.Writer) {
	for local269 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local269]
			write16(w, uint16(x))
		}
	}
	for local270 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local270]
			write16(w, uint16(x))
		}
	}
}

func (obj *PointedNode) Deserialize(r io.Reader) {
	for local271 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local271]
			*p = int16(read16(r))
		}
	}
	for local272 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local272]
			*p = int16(read16(r))
		}
	}
}

func (obj *PointedAO) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
}

func (obj *PointedAO) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
}

func (obj *CompressionModes) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *CompressionModes) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *PlayerPos) Serialize(w io.Writer) {
	for local273 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local273]
			write32(w, uint32(x))
		}
	}
	for local274 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local274]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		write32(w, uint32(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Keys", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		write8(w, uint8(x))
	}
}

func (obj *PlayerPos) Deserialize(r io.Reader) {
	for local275 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local275]
			*p = int32(read32(r))
		}
	}
	for local276 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local276]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		*p = int32(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		*p = int32(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Keys", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		*p = read8(r)
	}
}

func (obj *Interaction) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Interaction) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *SoundID) Serialize(w io.Writer) {
	{
		x := *(*(int32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *SoundID) Deserialize(r io.Reader) {
	{
		p := &*(*(int32))(obj)
		*p = int32(read32(r))
	}
}

func (obj *Field) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))[:])
		chk(err)
	}
}

func (obj *Field) Deserialize(r io.Reader) {
	var local277 []uint8
	var local278 uint16
	{
		p := &local278
		*p = read16(r)
	}
	(local277) = make([]uint8, local278)
	{
		_, err := io.ReadFull(r, (local277)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name) = string(local277)
	var local279 []uint8
	var local280 uint32
	{
		p := &local280
		*p = read32(r)
	}
	(local279) = make([]uint8, local280)
	{
		_, err := io.ReadFull(r, (local279)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value) = string(local279)
}

func (obj *AuthMethods) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *AuthMethods) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *Pos) Serialize(w io.Writer) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *Pos) Deserialize(r io.Reader) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
}

func (obj *KickReason) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *KickReason) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlk) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.LitFromBlks", err))
	}
	{
		local281 := uint8(2) // Size of param0 in bytes.
		{
			x := local281
			write8(w, uint8(x))
		}
	}
	{
		local282 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			x := local282
			write8(w, uint8(x))
		}
	}
	for local283 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local283]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			if x == nil {
				write8(w, 0)
			} else {
				write8(w, 2)
				// len(map[uint16]...) always < math.MaxUint16
				write16(w, uint16(len(x)))
				keys := make([]uint16, 0, len(x))
				for key := range x {
					keys = append(keys, key)
				}
				sort.Slice(keys, func(i, j int) bool {
					i2pos := func(i int) [3]int16 {
						return Blkpos2Pos([3]int16{}, keys[i])
					}
					p, q := i2pos(i), i2pos(j)
					for i := range p {
						switch {
						case p[i] < q[i]:
							return true
						case p[i] > q[i]:
							return false
						}
					}
					return false
				})
				for _, key := range keys {
					write16(w, key)
					chk(serialize(w, x[key]))
				}
			}
		}
	}
}

func (obj *MapBlk) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.LitFromBlks", err))
	}
	{
		var local284 uint8
		local285 := uint8(2) // Size of param0 in bytes.
		{
			p := &local284
			*p = read8(r)
		}
		if local284 != local285 {
			chk(fmt.Errorf("const %v: %v", "uint8(2)     // Size of param0 in bytes.", local284))
		}
	}
	{
		var local286 uint8
		local287 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			p := &local286
			*p = read8(r)
		}
		if local286 != local287 {
			chk(fmt.Errorf("const %v: %v", "uint8(1 + 1) // Size of param1 and param2 combined, in bytes.", local286))
		}
	}
	for local288 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local288]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			switch ver := read8(r); ver {
			case 0:
				*p = nil
			case 2:
				n := read16(r)
				*p = make(map[uint16]*NodeMeta, n)
				for ; n > 0; n-- {
					pos := read16(r)
					nm := new(NodeMeta)
					chk(deserialize(r, nm))
					(*p)[pos] = nm
				}
			default:
				chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
			}
		}
	}
}

func (obj *Node) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		write8(w, uint8(x))
	}
}

func (obj *Node) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		*p = read8(r)
	}
}

func (obj *CSMRestrictionFlags) Serialize(w io.Writer) {
	{
		x := *(*(uint64))(obj)
		write64(w, uint64(x))
	}
}

func (obj *CSMRestrictionFlags) Deserialize(r io.Reader) {
	{
		p := &*(*(uint64))(obj)
		*p = read64(r)
	}
}

func (obj *Vec) Serialize(w io.Writer) {
	for local289 := range *(*([3]float32))(obj) {
		{
			x := (*(*([3]float32))(obj))[local289]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *Vec) Deserialize(r io.Reader) {
	for local290 := range *(*([3]float32))(obj) {
		{
			p := &(*(*([3]float32))(obj))[local290]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ChatMsgType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ChatMsgType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOID) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *AOID) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOAdd) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		local291 := genericCAO
		if err := pcall(func() {
			(local291).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.aoType", err))
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOInitData", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *AOAdd) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		var local292 aoType
		local293 := genericCAO
		if err := pcall(func() {
			(local292).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.aoType", err))
		}
		if local292 != local293 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local292))
		}
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOInitData", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *IDAOMsg) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			writeAOMsg(w, x)
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *IDAOMsg) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			{
				var err error
				*p, err = readAOMsg(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ItemDef) Serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local294 := uint8(6)
			{
				x := local294
				write8(w, uint8(x))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Type).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ItemType", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Desc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Desc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Desc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvImg).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldImg).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		for local295 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).WieldScale {
			{
				x := ((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).WieldScale)[local295]
				write32(w, math.Float32bits(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).StackMax
			write16(w, uint16(x))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Usable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).CanPointLiquids
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ToolCaps).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ToolCaps", err))
		}
		if len(((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local296 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).Groups)[local296]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
			}
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).PlacePredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlacePredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlacePredict))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceSnd).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceFailSnd).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PointRange
			write32(w, math.Float32bits(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Palette).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvOverlay).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldOverlay).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).ShortDesc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ShortDesc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ShortDesc))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceParam2
			write8(w, uint8(x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ItemDef) Deserialize(r io.Reader) {
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local297 uint8
			local298 := uint8(6)
			{
				p := &local297
				*p = read8(r)
			}
			if local297 != local298 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local297))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Type).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ItemType", err))
		}
		var local299 []uint8
		var local300 uint16
		{
			p := &local300
			*p = read16(r)
		}
		(local299) = make([]uint8, local300)
		{
			_, err := io.ReadFull(r, (local299)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Name) = string(local299)
		var local301 []uint8
		var local302 uint16
		{
			p := &local302
			*p = read16(r)
		}
		(local301) = make([]uint8, local302)
		{
			_, err := io.ReadFull(r, (local301)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Desc) = string(local301)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvImg).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldImg).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		for local303 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).WieldScale {
			{
				p := &((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).WieldScale)[local303]
				*p = math.Float32frombits(read32(r))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).StackMax
			*p = read16(r)
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Usable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).CanPointLiquids
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ToolCaps).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ToolCaps", err))
		}
		var local304 uint16
		{
			p := &local304
			*p = read16(r)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups) = make([]Group, local304)
		for local305 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).Groups)[local305]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
			}
		}
		var local306 []uint8
		var local307 uint16
		{
			p := &local307
			*p = read16(r)
		}
		(local306) = make([]uint8, local307)
		{
			_, err := io.ReadFull(r, (local306)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).PlacePredict) = string(local306)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceSnd).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceFailSnd).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PointRange
			*p = math.Float32frombits(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Palette).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvOverlay).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldOverlay).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
		var local308 []uint8
		var local309 uint16
		{
			p := &local309
			*p = read16(r)
		}
		(local308) = make([]uint8, local309)
		{
			_, err := io.ReadFull(r, (local308)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).ShortDesc) = string(local308)
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceParam2
			*p = read8(r)
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *SoundSrcType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *SoundSrcType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileAnim) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := w.Write(((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local310 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				x := ((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local310]
				write16(w, uint16(x))
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			x := (*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TileAnim) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local311 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				p := &((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local311]
				*p = read16(r)
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			p := &(*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *Content) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *Content) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *ParticleSpawnerID) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *ParticleSpawnerID) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDID) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDID) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUD) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDType", err))
	}
	for local312 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local312]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))[:])
		chk(err)
	}
	for local313 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local313]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		write32(w, uint32(x))
	}
	for local314 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local314]
			write32(w, math.Float32bits(x))
		}
	}
	for local315 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local315]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	for local316 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local316]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDStyleFlags", err))
	}
}

func (obj *HUD) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDType", err))
	}
	for local317 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local317]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local318 []uint8
	var local319 uint16
	{
		p := &local319
		*p = read16(r)
	}
	(local318) = make([]uint8, local319)
	{
		_, err := io.ReadFull(r, (local318)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name) = string(local318)
	for local320 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local320]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local321 []uint8
	var local322 uint16
	{
		p := &local322
		*p = read16(r)
	}
	(local321) = make([]uint8, local322)
	{
		_, err := io.ReadFull(r, (local321)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text) = string(local321)
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		*p = read32(r)
	}
	for local323 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local323]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local324 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local324]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	for local325 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local325]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		*p = int16(read16(r))
	}
	var local326 []uint8
	var local327 uint16
	{
		p := &local327
		*p = read16(r)
	}
	(local326) = make([]uint8, local327)
	{
		_, err := io.ReadFull(r, (local326)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2) = string(local326)
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.HUDStyleFlags", err))
	}
}

func (obj *HUDField) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDField) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDStyleFlags) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDStyleFlags) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDFlags) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDFlags) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HotbarParam) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *HotbarParam) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Texture) Serialize(w io.Writer) {
	if len(([]byte(*(*(string))(obj)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte(*(*(string))(obj)))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte(*(*(string))(obj)))[:])
		chk(err)
	}
}

func (obj *Texture) Deserialize(r io.Reader) {
	var local328 []uint8
	var local329 uint16
	{
		p := &local329
		*p = read16(r)
	}
	(local328) = make([]uint8, local329)
	{
		_, err := io.ReadFull(r, (local328)[:])
		chk(err)
	}
	(*(*(string))(obj)) = string(local328)
}

func (obj *PlayerListUpdateType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerListUpdateType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ModChanSig) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ModChanSig) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOProps) Serialize(w io.Writer) {
	{
		local330 := uint8(4)
		{
			x := local330
			write8(w, uint8(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))[:])
		chk(err)
	}
	for local331 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local331]
			write32(w, math.Float32bits(x))
		}
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local332 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local332]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
	}
	for local333 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local333]
			write16(w, uint16(x))
		}
	}
	for local334 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local334]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))[:])
		chk(err)
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Colors)))
		write16(w, uint16(x))
	}
	for local335 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local335]
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
}

func (obj *AOProps) Deserialize(r io.Reader) {
	{
		var local336 uint8
		local337 := uint8(4)
		{
			p := &local336
			*p = read8(r)
		}
		if local336 != local337 {
			chk(fmt.Errorf("const %v: %v", "uint8(4)", local336))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local338 []uint8
	var local339 uint16
	{
		p := &local339
		*p = read16(r)
	}
	(local338) = make([]uint8, local339)
	{
		_, err := io.ReadFull(r, (local338)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual) = string(local338)
	for local340 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local340]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local341 uint16
	{
		p := &local341
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures) = make([]Texture, local341)
	for local342 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local342]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
		}
	}
	for local343 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local343]
			*p = int16(read16(r))
		}
	}
	for local344 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local344]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local345 []uint8
	var local346 uint16
	{
		p := &local346
		*p = read16(r)
	}
	(local345) = make([]uint8, local346)
	{
		_, err := io.ReadFull(r, (local345)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh) = string(local345)
	var local347 uint16
	{
		p := &local347
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors) = make([]color.NRGBA, local347)
	for local348 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local348]
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local349 []uint8
	var local350 uint16
	{
		p := &local350
		*p = read16(r)
	}
	(local349) = make([]uint8, local350)
	{
		_, err := io.ReadFull(r, (local349)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag) = string(local349)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local351 []uint8
	var local352 uint16
	{
		p := &local352
		*p = read16(r)
	}
	(local351) = make([]uint8, local352)
	{
		_, err := io.ReadFull(r, (local351)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext) = string(local351)
	var local353 []uint8
	var local354 uint16
	{
		p := &local354
		*p = read16(r)
	}
	(local353) = make([]uint8, local354)
	{
		_, err := io.ReadFull(r, (local353)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring) = string(local353)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		*p = int8(read8(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
}

func (obj *AOPos) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local355 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local355]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPos) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local356 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local356]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOSprite) Serialize(w io.Writer) {
	for local357 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			x := ((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local357]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOSprite) Deserialize(r io.Reader) {
	for local358 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			p := &((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local358]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *Group) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		write16(w, uint16(x))
	}
}

func (obj *Group) Deserialize(r io.Reader) {
	var local359 []uint8
	var local360 uint16
	{
		p := &local360
		*p = read16(r)
	}
	(local359) = make([]uint8, local360)
	{
		_, err := io.ReadFull(r, (local359)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name) = string(local359)
	{
		p := &(*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		*p = int16(read16(r))
	}
}

func (obj *AOAnim) Serialize(w io.Writer) {
	for local361 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			x := ((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local361]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAnim) Deserialize(r io.Reader) {
	for local362 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			p := &((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local362]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOBonePos) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local363 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local363]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *AOBonePos) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local364 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local364]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *AOAttach) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	if len(([]byte((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local365 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local365]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAttach) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	var local366 []uint8
	var local367 uint16
	{
		p := &local367
		*p = read16(r)
	}
	(local366) = make([]uint8, local367)
	{
		_, err := io.ReadFull(r, (local366)[:])
		chk(err)
	}
	((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone) = string(local366)
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
	}
	for local368 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local368]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPhysOverride) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOPhysOverride) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *aoType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *aoType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeMetaField) Serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
	}
	{
		x := (*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *NodeMetaField) Deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Field", err))
	}
	{
		p := &(*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *MinimapType) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *MinimapType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Param1Type) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param1Type) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Param2Type) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param2Type) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DrawType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DrawType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileDef) Serialize(w io.Writer) {
	{
		local369 := uint8(6)
		{
			x := local369
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AlignType", err))
		}
	}
}

func (obj *TileDef) Deserialize(r io.Reader) {
	{
		var local370 uint8
		local371 := uint8(6)
		{
			p := &local370
			*p = read8(r)
		}
		if local370 != local371 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local370))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AlignType", err))
		}
	}
}

func (obj *WaveType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *WaveType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LiquidType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *LiquidType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBox) Serialize(w io.Writer) {
	{
		local372 := uint8(6)
		{
			x := local372
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).Fixed)))
			write16(w, uint16(x))
		}
		for local373 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local373]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DirBoxes", err))
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoAll)))
			write16(w, uint16(x))
		}
		for local374 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local374]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoSides)))
			write16(w, uint16(x))
		}
		for local375 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local375]).Serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
	}
}

func (obj *NodeBox) Deserialize(r io.Reader) {
	{
		var local376 uint8
		local377 := uint8(6)
		{
			p := &local376
			*p = read8(r)
		}
		if local376 != local377 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local376))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		var local378 uint16
		{
			p := &local378
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed) = make([]Box, local378)
		for local379 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local379]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DirBoxes", err))
		}
		var local380 uint16
		{
			p := &local380
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll) = make([]Box, local380)
		for local381 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local381]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
		var local382 uint16
		{
			p := &local382
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides) = make([]Box, local382)
		for local383 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local383]).Deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
			}
		}
	}
}

func (obj *SoundDef) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
}

func (obj *SoundDef) Deserialize(r io.Reader) {
	var local384 []uint8
	var local385 uint16
	{
		p := &local385
		*p = read16(r)
	}
	(local384) = make([]uint8, local385)
	{
		_, err := io.ReadFull(r, (local384)[:])
		chk(err)
	}
	((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name) = string(local384)
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AlphaUse) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlphaUse) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Keys) Serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *Keys) Deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *MapBlkFlags) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *MapBlkFlags) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LitFromBlks) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *LitFromBlks) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOInitData) Serialize(w io.Writer) {
	{
		local386 := uint8(1)
		{
			x := local386
			write8(w, uint8(x))
		}
	}
	if len(([]byte((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).Serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	for local387 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			x := ((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local387]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			if len(x) > math.MaxUint8 {
				chk(ErrTooLong)
			}
			write8(w, uint8(len(x)))
			for _, msg := range x {
				var b bytes.Buffer
				chk(writeAOMsg(&b, msg))
				if b.Len() > math.MaxUint32 {
					chk(ErrTooLong)
				}
				write32(w, uint32(b.Len()))
				_, err := b.WriteTo(w)
				chk(err)
			}
		}
	}
}

func (obj *AOInitData) Deserialize(r io.Reader) {
	{
		var local388 uint8
		local389 := uint8(1)
		{
			p := &local388
			*p = read8(r)
		}
		if local388 != local389 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local388))
		}
	}
	var local390 []uint8
	var local391 uint16
	{
		p := &local391
		*p = read16(r)
	}
	(local390) = make([]uint8, local391)
	{
		_, err := io.ReadFull(r, (local390)[:])
		chk(err)
	}
	((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name) = string(local390)
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).Deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Pos", err))
	}
	for local392 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			p := &((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local392]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			*p = make([]AOMsg, read8(r))
			for i := range *p {
				r := &io.LimitedReader{R: r, N: int64(read32(r))}
				msg, err := readAOMsg(r)
				chk(err)
				(*p)[i] = msg
				if r.N > 0 {
					chk(fmt.Errorf("%d bytes of trailing data", r.N))
				}
			}
		}
	}
}

func (obj *ItemType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ItemType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ToolCaps) Serialize(w io.Writer) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			x := (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		/*
			if r.N > 0 { (*(*(struct {
				//mt:if _ = %s; false
				NonNil	bool

				AttackCooldown	float32
				MaxDropLvl	int16

				//mt:len32
				GroupCaps	[]ToolGroupCap

				//mt:len32
				DmgGroups	[]Group

				//mt:32tou16
				PunchUses	int32
			}))(obj)).NonNil = true}; /*
		*/{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					local393 := uint8(5)
					{
						x := local393
						write8(w, uint8(x))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					write32(w, math.Float32bits(x))
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					write16(w, uint16(x))
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).GroupCaps)))
					write32(w, uint32(x))
				}
				for local394 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local394]).Serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ToolGroupCap", err))
					}
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).DmgGroups)))
					write32(w, uint32(x))
				}
				for local395 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local395]).Serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
					}
				}
				{
					x := uint16((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).PunchUses)
					write16(w, uint16(x))
				}
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToolCaps) Deserialize(r io.Reader) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			p := &(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if r.N > 0 {
			(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil = true
		} /**/
		{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					var local396 uint8
					local397 := uint8(5)
					{
						p := &local396
						*p = read8(r)
					}
					if local396 != local397 {
						chk(fmt.Errorf("const %v: %v", "uint8(5)", local396))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					*p = math.Float32frombits(read32(r))
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					*p = int16(read16(r))
				}
				var local398 uint32
				{
					p := &local398
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps) = make([]ToolGroupCap, local398)
				for local399 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local399]).Deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.ToolGroupCap", err))
					}
				}
				var local400 uint32
				{
					p := &local400
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups) = make([]Group, local400)
				for local401 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local401]).Deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Group", err))
					}
				}
				var local402 uint16
				{
					p := &local402
					*p = read16(r)
				}
				(*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).PunchUses = int32(local402)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *AnimType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AnimType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Box) Serialize(w io.Writer) {
	for local403 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local403]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
		}
	}
}

func (obj *Box) Deserialize(r io.Reader) {
	for local404 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local404]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Vec", err))
		}
	}
}

func (obj *TileFlags) Serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *TileFlags) Deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AlignType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlignType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBoxType) Serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *NodeBoxType) Deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DirBoxes) Serialize(w io.Writer) {
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Top)))
		write16(w, uint16(x))
	}
	for local405 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local405]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Bot)))
		write16(w, uint16(x))
	}
	for local406 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local406]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Front)))
		write16(w, uint16(x))
	}
	for local407 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local407]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Left)))
		write16(w, uint16(x))
	}
	for local408 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local408]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Back)))
		write16(w, uint16(x))
	}
	for local409 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local409]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Right)))
		write16(w, uint16(x))
	}
	for local410 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local410]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
}

func (obj *DirBoxes) Deserialize(r io.Reader) {
	var local411 uint16
	{
		p := &local411
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top) = make([]Box, local411)
	for local412 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local412]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	var local413 uint16
	{
		p := &local413
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot) = make([]Box, local413)
	for local414 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local414]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	var local415 uint16
	{
		p := &local415
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front) = make([]Box, local415)
	for local416 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local416]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	var local417 uint16
	{
		p := &local417
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left) = make([]Box, local417)
	for local418 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local418]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	var local419 uint16
	{
		p := &local419
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back) = make([]Box, local419)
	for local420 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local420]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
	var local421 uint16
	{
		p := &local421
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right) = make([]Box, local421)
	for local422 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local422]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.Box", err))
		}
	}
}

func (obj *ToolGroupCap) Serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := int16((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses)
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Times)))
		write32(w, uint32(x))
	}
	for local423 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local423]).Serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DigTime", err))
		}
	}
}

func (obj *ToolGroupCap) Deserialize(r io.Reader) {
	var local424 []uint8
	var local425 uint16
	{
		p := &local425
		*p = read16(r)
	}
	(local424) = make([]uint8, local425)
	{
		_, err := io.ReadFull(r, (local424)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name) = string(local424)
	var local426 int16
	{
		p := &local426
		*p = int16(read16(r))
	}
	(*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Uses = int32(local426)
	{
		p := &(*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		*p = int16(read16(r))
	}
	var local427 uint32
	{
		p := &local427
		*p = read32(r)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times) = make([]DigTime, local427)
	for local428 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local428]).Deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/dragonfireclient/mt.DigTime", err))
		}
	}
}

func (obj *DigTime) Serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		write32(w, math.Float32bits(x))
	}
}

func (obj *DigTime) Deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		*p = math.Float32frombits(read32(r))
	}
}
